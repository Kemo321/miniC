### How It Works
The IRGenerator class, inheriting from ASTVisitor, walks the AST to build an IRProgram by emitting instructions during traversal. It starts with generate on the Program, creating an IRProgram and visiting each Function to make an IRFunction with an entry BasicBlock, mapping parameters to variables, and clearing counters for temps/labels. For statements, it dispatches: variable declarations assign initializers if present, assignments compute values and store, returns emit RETURN ops, ifs create then/else/end blocks with conditional jumps, and whiles set up cond/body/end with loops. Expressions are handled recursively in generate_expr, producing temps for literals (direct assign), identifiers (lookup map), unaries (NEG/NOT), and binaries (map token ops to IROpcode like PLUS to ADD). It uses counters for unique temps ("tN") and labels (prefixed_N), a map for variable tracking, and emit to append instructions to the current block. Throws on unsupported nodes.

### Example of Use
Call generate on a Program AST to produce an IRProgram; for a function with an if statement checking a condition and assigning in branches, it creates separate blocks, emits JUMPIFNOT to skip else, generates expr temps for the condition, and jumps to end labels, resulting in structured IR ready for code generation like translating a conditional assignment into branched assembly.