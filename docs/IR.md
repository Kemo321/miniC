### How It Works
The IR (Intermediate Representation) module structures compiled code as a platform-independent format using three-address instructions. The IROpcode enum lists operations like arithmetic (ADD, SUB), comparisons (EQ, LT), assignments (ASSIGN), memory access (LOAD, STORE), control flow (JUMP, JUMPIF), returns, and labels. An IRInstruction holds an opcode plus up to two operands and a result (for temps or labels). BasicBlock groups instructions under a unique label for control flow units. IRFunction encapsulates a function's name, return type, parameters, and owned basic blocks. The top-level IRProgram owns all functions. This setup allows linear scanning for optimizations and easy translation to assembly, with strings for variable/temporary names and vectors for collections.

### Example of Use
From an AST, generate an IRProgram by creating IRInstructions for operations (e.g., ASSIGN for variable init, ADD for binary plus), grouping them into labeled BasicBlocks for conditionals (like then/else for if), assembling blocks into an IRFunction for main, and adding it to the IRProgram. This IR can then be passed to a code generator to produce assembly for a loop that increments a counter until a condition.